#include <stdio.h>
#include <stdlib.h>

#define X 12
#define Y 25
#define PATH_SIZE 50

char path[PATH_SIZE] = { 0 };

char _map[Y][X] = {
  {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '0', '0', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '1', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '1'},
  {'1', '0', '1', '1', '1', '0', '1', '0', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1'},
  {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '0', '0', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '1', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '1'},
  {'1', '0', '1', '1', '1', '0', '1', '0', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1'},
  {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}
};

const char originalMap[Y][X] = {
  {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '0', '0', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '1', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '1'},
  {'1', '0', '1', '1', '1', '0', '1', '0', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1'},
  {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '0', '0', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '1', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '1', '1', '1'},
  {'1', '0', '1', '1', '1', '0', '1', '0', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1'},
  {'1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}
};

void printMap()
{
  int x = 0;
  int y = 0;
  for (y = 0; y < Y; y++)
  {
    for (x = 0; x < X; x++)
    {
      if (_map[y][x] == '1')
      {
        putchar(219);
      }
      else if (_map[y][x] == '0')
      {
        putchar(255);
      }
      else
      {
        putchar(_map[y][x]);
      }
    }
    printf("\n");
  }
}

int pathfind(int x1, int y1, int x2, int y2)
{
  int count = 0;
  int flag = 1;
  int i = 0;
  int x = x1;
  int y = y1;
  int counter = 0;
  char check[4] = { 'U', 'R', 'D', 'L' };

  if (_map[y2][x2] == '1')
  {
    printf("(x2,y2) is a wall.\n");
    return 0;
  }
  if (_map[y1][x1] == '1')
  {
    printf("(x1,y1) is a wall.\n");
    return 0;
  }

  for (i = 0; i < PATH_SIZE; i++)
  {
    path[i] = 0;
  }

  while (x != x2 || y != y2)
  {
    if (_map[y][x] == '+')
    {
      printf("Stuck, Could not find a suitable path!\n");
      counter = 0;
      x = x1;
      y = y1;
      blockPath(x1, y1);
    }

    _map[y][x] = '+';
    flag = 1;
    count = 0;

    if (_map[y][x + 1] == '0' || _map[y][x + 1] == '+')
    {
      count++;
    }
    if (_map[y][x - 1] == '0' || _map[y][x - 1] == '+')
    {
      count++;
    }
    if (_map[y + 1][x] == '0' || _map[y + 1][x] == '+')
    {
      count++;
    }
    if (_map[y - 1][x] == '0' || _map[y - 1][x] == '+')
    {
      count++;
    }
    if (count > 2)
    {
      //printf("*");
      path[counter++] = '*';
    }

    if (y <= y2 && x <= x2)
    {
      if (y2 - y > x2 - x)
      {
        check[0] = 'U';
        check[1] = 'L';
        check[2] = 'D';
        check[3] = 'R';
      }
      else
      {
        check[0] = 'L';
        check[1] = 'U';
        check[2] = 'R';
        check[3] = 'D';
      }
    }
    else if (y <= y2 && x >= x2)
    {
      if (y2 - y > x - x2)
      {
        check[0] = 'U';
        check[1] = 'R';
        check[2] = 'D';
        check[3] = 'L';
      }
      else
      {
        check[0] = 'R';
        check[1] = 'U';
        check[2] = 'L';
        check[3] = 'D';
      }
    }
    else if (y >= y2 && x <= x2)
    {
      if (y - y2 > x2 - x)
      {
        check[0] = 'D';
        check[1] = 'L';
        check[2] = 'U';
        check[3] = 'R';
      }
      else
      {
        check[0] = 'L';
        check[1] = 'D';
        check[2] = 'R';
        check[3] = 'U';
      }
    }
    else if (y >= y2 && x >= x2)
    {
      if (y - y2 > x - x2)
      {
        check[0] = 'D';
        check[1] = 'R';
        check[2] = 'U';
        check[3] = 'L';
      }
      else
      {
        check[0] = 'R';
        check[1] = 'D';
        check[2] = 'L';
        check[3] = 'U';
      }
    }
    for (i = 0; i < 4 && flag; i++)
    {
      switch (check[i])
      {
      case 'U':
        if (_map[y + 1][x] == '0')
        {
          //putchar(check[i]);
          path[counter++] = check[i];
          y++;
          flag = 0;
        }
        break;
      case 'R':
        if (_map[y][x - 1] == '0')
        {
          //putchar(check[i]);
          path[counter++] = check[i];
          x--;
          flag = 0;
        }
        break;
      case 'D':
        if (_map[y - 1][x] == '0')
        {
          //putchar(check[i]);
          path[counter++] = check[i];
          y--;
          flag = 0;
        }
        break;
      case 'L':
        if (_map[y][x + 1] == '0')
        {
          //putchar(check[i]);
          path[counter++] = check[i];
          x++;
          flag = 0;
        }
        break;
      default:
        printf("Stuck, Could not find a suitable path!");
        break;
      }
    }
    //getchar();
    //printMap();
  }
  printf("\n");
  _map[y][x] = 'O';
  _map[y1][x1] = 'X';
  return 1;
}

void clearPath()
{
  int x = 0;
  int y = 0;
  int i = 0;
  for (y = 0; y < Y; y++)
  {
    for (x = 0; x < X; x++)
    {
      _map[y][x] = originalMap[y][x];
    }
  }
  for (i = 0; i < PATH_SIZE; i++)
  {
    path[i] = 0;
  }
}

void minimizePath()
{
  char newPath[PATH_SIZE] = { 0 };
  char last = 0;
  int i = 0;
  int counter = 0;
  for (i = 0; path[i]; i++)
  {
    if (path[i] != last && path[i] != '*')
    {
      newPath[counter++] = path[i];
      last = path[i];
    }
    else if (path[i] == '*')
    {
      last = path[i];
    }
  }

  for (i = 0; i < PATH_SIZE; i++)
  {
    path[i] = 0;
  }

  for (i = 0; i < counter; i++)
  {
    path[i] = newPath[i];
  }
}

void blockPath(int x1, int y1)
{
  int x = 0;
  int y = 0;
  int i = 0;

  for (y = 0; y < Y; y++)
  {
    for (x = 0; x < X; x++)
    {
      if (x == x1 && y == y1)
      {
        _map[y][x] = '0';
      }
      else if (_map[y][x] == '+')
      {
        _map[y][x] = '1';
      }
    }
  }

  for (i = 0; i < PATH_SIZE; i++)
  {
    path[i] = 0;
  }
}

void setup() {
  Serial.begin(9600);
}

void loop() {
  pathfind(4, 11, 7, 6);
  minimizePath();
  Serial.println(path);
  clearPath();
  delay(10000);
}